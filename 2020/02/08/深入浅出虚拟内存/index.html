<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="王志强">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="王志强">
    
    <meta name="keywords" content="C++,编程,深度学习">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>深入浅出虚拟内存 · this_is_for_u</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 4.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >this_is_for_u</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">深入浅出虚拟内存</a>
            </div>
    </div>
    
    <a class="home-link" href=/>this_is_for_u</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            深入浅出虚拟内存
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">10.9k</span>阅读时长: <span class="post-count reading-time">59 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/02/08</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>从这一系列文章翻译并结合自己理解提炼出来的，代码都自己实践过，有时间的也可以直接阅读英文原链接<br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-c-strings-proc/" target="_blank" rel="noopener">Hack The Virtual Memory: C strings &amp; /proc</a><br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-drawing-the-vm-diagram/" target="_blank" rel="noopener">Hack the Virtual Memory: drawing the VM diagram</a><br><a href="https://blog.holbertonschool.com/hack-the-virtual-memory-malloc-the-heap-the-program-break/" target="_blank" rel="noopener">Hack the Virtual Memory: malloc, the heap &amp; the program break</a>  </p>
<h3 id="通过-proc文件系统探究虚拟内存"><a href="#通过-proc文件系统探究虚拟内存" class="headerlink" title="通过/proc文件系统探究虚拟内存"></a>通过/proc文件系统探究虚拟内存</h3><p>本小节会通过/proc文件系统找到正在运行的进程的字符串所在的虚拟内存地址，并通过更改此内存地址的内容来更改字符串内容  </p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存是一种实现在计算机软硬件之间的内存管理技术，它将程序使用到的内存地址(虚拟地址)映射到计算机内存中的物理地址，虚拟内存使得应用程序从繁琐的管理内存空间任务中解放出来，提高了内存隔离带来的安全性，虚拟内存地址通常是连续的地址空间，由操作系统的内存管理模块控制，在触发缺页中断时利用分页技术将实际的物理内存分配给虚拟内存，而且64位机器虚拟内存的空间大小远超出实际物理内存的大小，使得进程可以使用比物理内存大小更多的内存空间。</p>
<p>在深入研究虚拟内存前，有几个关键点：</p>
<ul>
<li>每个进程都有它自己的虚拟内存</li>
<li>虚拟内存的大小取决于系统的体系结构</li>
<li>不同操作管理有着不同的管理虚拟内存的方式，但大多数操作系统的虚拟内存结构如下图：</li>
</ul>
<img width=350 src="/image/virtual_memory.png" >
上图并不是特别详细的内存管理图，高地址其实还有内核空间等等，但这不是这篇文章的主题。从图中可以看到高地址存储着命令行参数和环境变量，之后是栈空间、堆空间和可执行程序，其中栈空间向下延申，堆空间向上增长，堆空间需要使用malloc分配，是动态分配的内存的一部分。  

<p>首先通过一个简单的C程序探究虚拟内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - 使用strdup创建一个字符串的拷贝，strdup内部会使用malloc分配空间，</span><br><span class="line"> * 返回新空间的地址，这段地址空间需要外部自行使用free释放</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if malloc failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char *s;</span><br><span class="line"></span><br><span class="line">    s &#x3D; strdup(&quot;test_memory&quot;);</span><br><span class="line">    if (s &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Can&#39;t allocate mem with malloc\n&quot;);</span><br><span class="line">        return (EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%p\n&quot;, (void *)s);</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译运行：gcc -Wall -Wextra -pedantic -Werror main.c -o test; .&#x2F;test</span><br><span class="line">输出：0x88f010</span><br></pre></td></tr></table></figure>
<p>我的机器是64位机器，进程的虚拟内存高地址为0xffffffffffffffff， 低地址为0x0，而0x88f010远小于0xffffffffffffffff，因此大概可以推断出被复制的字符串的地址(堆地址)是在内存低地址附近，具体可以通过/proc文件系统验证.<br>ls /proc目录可以看到好多文件，这里主要关注/proc/[pid]/mem和/proc/[pid]/maps  </p>
<h5 id="mem-amp-maps"><a href="#mem-amp-maps" class="headerlink" title="mem &amp; maps"></a>mem &amp; maps</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">man proc</span><br><span class="line"></span><br><span class="line">&#x2F;proc&#x2F;[pid]&#x2F;mem</span><br><span class="line">    This file can be used to access the pages of a process&#39;s memory through open(2), read(2), and lseek(2).</span><br><span class="line"></span><br><span class="line">&#x2F;proc&#x2F;[pid]&#x2F;maps</span><br><span class="line">    A  file containing the currently mapped memory regions and their access permissions.</span><br><span class="line">          See mmap(2) for some further information about memory mappings.</span><br><span class="line"></span><br><span class="line">              The format of the file is:</span><br><span class="line"></span><br><span class="line">       address           perms offset  dev   inode       pathname</span><br><span class="line">       00400000-00452000 r-xp 00000000 08:02 173521      &#x2F;usr&#x2F;bin&#x2F;dbus-daemon</span><br><span class="line">       00651000-00652000 r--p 00051000 08:02 173521      &#x2F;usr&#x2F;bin&#x2F;dbus-daemon</span><br><span class="line">       00652000-00655000 rw-p 00052000 08:02 173521      &#x2F;usr&#x2F;bin&#x2F;dbus-daemon</span><br><span class="line">       00e03000-00e24000 rw-p 00000000 00:00 0           [heap]</span><br><span class="line">       00e24000-011f7000 rw-p 00000000 00:00 0           [heap]</span><br><span class="line">       ...</span><br><span class="line">       35b1800000-35b1820000 r-xp 00000000 08:02 135522  &#x2F;usr&#x2F;lib64&#x2F;ld-2.15.so</span><br><span class="line">       35b1a1f000-35b1a20000 r--p 0001f000 08:02 135522  &#x2F;usr&#x2F;lib64&#x2F;ld-2.15.so</span><br><span class="line">       35b1a20000-35b1a21000 rw-p 00020000 08:02 135522  &#x2F;usr&#x2F;lib64&#x2F;ld-2.15.so</span><br><span class="line">       35b1a21000-35b1a22000 rw-p 00000000 00:00 0</span><br><span class="line">       35b1c00000-35b1dac000 r-xp 00000000 08:02 135870  &#x2F;usr&#x2F;lib64&#x2F;libc-2.15.so</span><br><span class="line">       35b1dac000-35b1fac000 ---p 001ac000 08:02 135870  &#x2F;usr&#x2F;lib64&#x2F;libc-2.15.so</span><br><span class="line">       35b1fac000-35b1fb0000 r--p 001ac000 08:02 135870  &#x2F;usr&#x2F;lib64&#x2F;libc-2.15.so</span><br><span class="line">       35b1fb0000-35b1fb2000 rw-p 001b0000 08:02 135870  &#x2F;usr&#x2F;lib64&#x2F;libc-2.15.so</span><br><span class="line">       ...</span><br><span class="line">       f2c6ff8c000-7f2c7078c000 rw-p 00000000 00:00 0    [stack:986]</span><br><span class="line">       ...</span><br><span class="line">       7fffb2c0d000-7fffb2c2e000 rw-p 00000000 00:00 0   [stack]</span><br><span class="line">       7fffb2d48000-7fffb2d49000 r-xp 00000000 00:00 0   [vdso]</span><br><span class="line"></span><br><span class="line">              The address field is the address space in the process that the mapping occupies.</span><br><span class="line">          The perms field is a set of permissions:</span><br><span class="line"></span><br><span class="line">                   r &#x3D; read</span><br><span class="line">                   w &#x3D; write</span><br><span class="line">                   x &#x3D; execute</span><br><span class="line">                   s &#x3D; shared</span><br><span class="line">                   p &#x3D; private (copy on write)</span><br><span class="line"></span><br><span class="line">              The offset field is the offset into the file&#x2F;whatever;</span><br><span class="line">          dev is the device (major:minor); inode is the inode on that device.   0  indicates</span><br><span class="line">              that no inode is associated with the memory region,</span><br><span class="line">          as would be the case with BSS (uninitialized data).</span><br><span class="line"></span><br><span class="line">              The  pathname field will usually be the file that is backing the mapping.</span><br><span class="line">          For ELF files, you can easily coordinate with the offset field</span><br><span class="line">              by looking at the Offset field in the ELF program headers (readelf -l).</span><br><span class="line"></span><br><span class="line">              There are additional helpful pseudo-paths:</span><br><span class="line"></span><br><span class="line">                   [stack]</span><br><span class="line">                          The initial process&#39;s (also known as the main thread&#39;s) stack.</span><br><span class="line"></span><br><span class="line">                   [stack:&lt;tid&gt;] (since Linux 3.4)</span><br><span class="line">                          A thread&#39;s stack (where the &lt;tid&gt; is a thread ID).</span><br><span class="line">              It corresponds to the &#x2F;proc&#x2F;[pid]&#x2F;task&#x2F;[tid]&#x2F; path.</span><br><span class="line"></span><br><span class="line">                   [vdso] The virtual dynamically linked shared object.</span><br><span class="line"></span><br><span class="line">                   [heap] The process&#39;s heap.</span><br><span class="line"></span><br><span class="line">              If the pathname field is blank, this is an anonymous mapping as obtained via the mmap(2) function.</span><br><span class="line">          There is no easy  way  to  coordinate</span><br><span class="line">              this back to a process&#39;s source, short of running it through gdb(1), strace(1), or similar.</span><br><span class="line"></span><br><span class="line">              Under Linux 2.0 there is no field giving pathname.</span><br></pre></td></tr></table></figure>
<p>通过mem文件可以访问和修改整个进程的内存页，通过maps可以看到进程当前已映射的内存区域，有地址和访问权限偏移量等，从maps中可以看到堆空间是在低地址而栈空间是在高地址.  从maps中可以看到heap的访问权限是rw，即可写，所以可以通过堆地址找到上个示例程序中字符串的地址，并通过修改mem文件对应地址的内容，就可以修改字符串的内容啦，程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**              </span><br><span class="line"> * main - uses strdup to create a new string, loops forever-ever</span><br><span class="line"> *                </span><br><span class="line"> * Return: EXIT_FAILURE if malloc failed. Other never returns</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">     char *s;</span><br><span class="line">     unsigned long int i;</span><br><span class="line"></span><br><span class="line">     s &#x3D; strdup(&quot;test_memory&quot;);</span><br><span class="line">     if (s &#x3D;&#x3D; NULL)</span><br><span class="line">     &#123;</span><br><span class="line">          fprintf(stderr, &quot;Can&#39;t allocate mem with malloc\n&quot;);</span><br><span class="line">          return (EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line">     i &#x3D; 0;</span><br><span class="line">     while (s)</span><br><span class="line">     &#123;</span><br><span class="line">          printf(&quot;[%lu] %s (%p)\n&quot;, i, s, (void *)s);</span><br><span class="line">          sleep(1);</span><br><span class="line">          i++;</span><br><span class="line">     &#125;</span><br><span class="line">     return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行：gcc -Wall -Wextra -pedantic -Werror main.c -o loop; .&#x2F;loop</span><br><span class="line">输出：</span><br><span class="line">[0] test_memory (0x21dc010)</span><br><span class="line">[1] test_memory (0x21dc010)</span><br><span class="line">[2] test_memory (0x21dc010)</span><br><span class="line">[3] test_memory (0x21dc010)</span><br><span class="line">[4] test_memory (0x21dc010)</span><br><span class="line">[5] test_memory (0x21dc010)</span><br><span class="line">[6] test_memory (0x21dc010)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里可以写一个脚本通过/proc文件系统找到字符串所在位置并修改其内容，相应的输出也会更改<br>首先找到进程的进程号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep .&#x2F;loop | grep -v grep</span><br><span class="line">zjucad    2542  0.0  0.0   4352   636 pts&#x2F;3    S+   12:28   0:00 .&#x2F;loop</span><br></pre></td></tr></table></figure>
<p>2542即为loop程序的进程号，cat /proc/2542/maps得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00400000-00401000 r-xp 00000000 08:01 811716                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;loop</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 811716                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;loop</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 811716                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;loop</span><br><span class="line">021dc000-021fd000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7f2adae2a000-7f2adafea000 r-xp 00000000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f2adafea000-7f2adb1ea000 ---p 001c0000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f2adb1ea000-7f2adb1ee000 r--p 001c0000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f2adb1ee000-7f2adb1f0000 rw-p 001c4000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f2adb1f0000-7f2adb1f4000 rw-p 00000000 00:00 0</span><br><span class="line">7f2adb1f4000-7f2adb21a000 r-xp 00000000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f2adb3fa000-7f2adb3fd000 rw-p 00000000 00:00 0</span><br><span class="line">7f2adb419000-7f2adb41a000 r--p 00025000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f2adb41a000-7f2adb41b000 rw-p 00026000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f2adb41b000-7f2adb41c000 rw-p 00000000 00:00 0</span><br><span class="line">7ffd51bb3000-7ffd51bd4000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffd51bdd000-7ffd51be0000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffd51be0000-7ffd51be2000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>看见堆地址范围021dc000-021fd000，并且可读可写，而且021dc000&lt;0x21dc010&lt;021fd000，这就可以确认字符串的地址在堆中，在堆中的索引是0x10(至于为什么是0x10，后面会讲到)，这时可以通过mem文件到0x21dc010地址修改内容，字符串输出的内容也会随之更改，这里通过python脚本实现此功能.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line">&#39;&#39;&#39;             </span><br><span class="line">Locates and replaces the first occurrence of a string in the heap</span><br><span class="line">of a process    </span><br><span class="line"></span><br><span class="line">Usage: .&#x2F;read_write_heap.py PID search_string replace_by_string</span><br><span class="line">Where:           </span><br><span class="line">- PID is the pid of the target process</span><br><span class="line">- search_string is the ASCII string you are looking to overwrite</span><br><span class="line">- replace_by_string is the ASCII string you want to replace</span><br><span class="line">  search_string with</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def print_usage_and_exit():</span><br><span class="line">    print(&#39;Usage: &#123;&#125; pid search write&#39;.format(sys.argv[0]))</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line"># check usage  </span><br><span class="line">if len(sys.argv) !&#x3D; 4:</span><br><span class="line">    print_usage_and_exit()</span><br><span class="line"></span><br><span class="line"># get the pid from args</span><br><span class="line">pid &#x3D; int(sys.argv[1])</span><br><span class="line">if pid &lt;&#x3D; 0:</span><br><span class="line">    print_usage_and_exit()</span><br><span class="line">search_string &#x3D; str(sys.argv[2])</span><br><span class="line">if search_string  &#x3D;&#x3D; &quot;&quot;:</span><br><span class="line">    print_usage_and_exit()</span><br><span class="line">write_string &#x3D; str(sys.argv[3])</span><br><span class="line">if search_string  &#x3D;&#x3D; &quot;&quot;:</span><br><span class="line">    print_usage_and_exit()</span><br><span class="line"></span><br><span class="line"># open the maps and mem files of the process</span><br><span class="line">maps_filename &#x3D; &quot;&#x2F;proc&#x2F;&#123;&#125;&#x2F;maps&quot;.format(pid)</span><br><span class="line">print(&quot;[*] maps: &#123;&#125;&quot;.format(maps_filename))</span><br><span class="line">mem_filename &#x3D; &quot;&#x2F;proc&#x2F;&#123;&#125;&#x2F;mem&quot;.format(pid)</span><br><span class="line">print(&quot;[*] mem: &#123;&#125;&quot;.format(mem_filename))</span><br><span class="line"></span><br><span class="line"># try opening the maps file</span><br><span class="line">try:</span><br><span class="line">    maps_file &#x3D; open(&#39;&#x2F;proc&#x2F;&#123;&#125;&#x2F;maps&#39;.format(pid), &#39;r&#39;)</span><br><span class="line">except IOError as e:</span><br><span class="line">    print(&quot;[ERROR] Can not open file &#123;&#125;:&quot;.format(maps_filename))</span><br><span class="line">    print(&quot;        I&#x2F;O error(&#123;&#125;): &#123;&#125;&quot;.format(e.errno, e.strerror))</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for line in maps_file:</span><br><span class="line">    sline &#x3D; line.split(&#39; &#39;)</span><br><span class="line">    # check if we found the heap</span><br><span class="line">    if sline[-1][:-1] !&#x3D; &quot;[heap]&quot;:</span><br><span class="line">        continue</span><br><span class="line">    print(&quot;[*] Found [heap]:&quot;)</span><br><span class="line"></span><br><span class="line">    # parse line</span><br><span class="line">    addr &#x3D; sline[0]</span><br><span class="line">    perm &#x3D; sline[1]</span><br><span class="line">    offset &#x3D; sline[2]</span><br><span class="line">    device &#x3D; sline[3]</span><br><span class="line">    inode &#x3D; sline[4]</span><br><span class="line">    pathname &#x3D; sline[-1][:-1]</span><br><span class="line">    print(&quot;\tpathname &#x3D; &#123;&#125;&quot;.format(pathname))</span><br><span class="line">    print(&quot;\taddresses &#x3D; &#123;&#125;&quot;.format(addr))</span><br><span class="line">    print(&quot;\tpermisions &#x3D; &#123;&#125;&quot;.format(perm))</span><br><span class="line">    print(&quot;\toffset &#x3D; &#123;&#125;&quot;.format(offset))</span><br><span class="line">    print(&quot;\tinode &#x3D; &#123;&#125;&quot;.format(inode))</span><br><span class="line"></span><br><span class="line">    # check if there is read and write permission</span><br><span class="line">    if perm[0] !&#x3D; &#39;r&#39; or perm[1] !&#x3D; &#39;w&#39;:</span><br><span class="line">        print(&quot;[*] &#123;&#125; does not have read&#x2F;write permission&quot;.format(pathname))</span><br><span class="line">        maps_file.close()</span><br><span class="line">        exit(0)</span><br><span class="line"></span><br><span class="line">    # get start and end of the heap in the virtual memory</span><br><span class="line">    addr &#x3D; addr.split(&quot;-&quot;)</span><br><span class="line">    if len(addr) !&#x3D; 2: # never trust anyone, not even your OS :)</span><br><span class="line">        print(&quot;[*] Wrong addr format&quot;)</span><br><span class="line">        maps_file.close()</span><br><span class="line">        exit(1)</span><br><span class="line">    addr_start &#x3D; int(addr[0], 16)</span><br><span class="line">    addr_end &#x3D; int(addr[1], 16)</span><br><span class="line">    print(&quot;\tAddr start [&#123;:x&#125;] | end [&#123;:x&#125;]&quot;.format(addr_start, addr_end))</span><br><span class="line"></span><br><span class="line">    # open and read mem</span><br><span class="line">    try:</span><br><span class="line">        mem_file &#x3D; open(mem_filename, &#39;rb+&#39;)</span><br><span class="line">    except IOError as e:</span><br><span class="line">        print(&quot;[ERROR] Can not open file &#123;&#125;:&quot;.format(mem_filename))</span><br><span class="line">        print(&quot;        I&#x2F;O error(&#123;&#125;): &#123;&#125;&quot;.format(e.errno, e.strerror))</span><br><span class="line">        maps_file.close()</span><br><span class="line">        exit(1)</span><br><span class="line"></span><br><span class="line">    # read heap  </span><br><span class="line">    mem_file.seek(addr_start)</span><br><span class="line">    heap &#x3D; mem_file.read(addr_end - addr_start)</span><br><span class="line"></span><br><span class="line">    # find string</span><br><span class="line">    try:</span><br><span class="line">        i &#x3D; heap.index(bytes(search_string, &quot;ASCII&quot;))</span><br><span class="line">    except Exception:</span><br><span class="line">        print(&quot;Can&#39;t find &#39;&#123;&#125;&#39;&quot;.format(search_string))</span><br><span class="line">        maps_file.close()</span><br><span class="line">        mem_file.close()</span><br><span class="line">        exit(0)</span><br><span class="line">    print(&quot;[*] Found &#39;&#123;&#125;&#39; at &#123;:x&#125;&quot;.format(search_string, i))</span><br><span class="line"></span><br><span class="line">    # write the new string</span><br><span class="line">    print(&quot;[*] Writing &#39;&#123;&#125;&#39; at &#123;:x&#125;&quot;.format(write_string, addr_start + i))</span><br><span class="line">    mem_file.seek(addr_start + i)</span><br><span class="line">    mem_file.write(bytes(write_string, &quot;ASCII&quot;))</span><br><span class="line"></span><br><span class="line">    # close files</span><br><span class="line">    maps_file.close()</span><br><span class="line">    mem_file.close()</span><br><span class="line"></span><br><span class="line">    # there is only one heap in our example</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>
<p>运行这个Python脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zjucad@zjucad-ONDA-H110-MINI-V3-01:~&#x2F;wangzhiqiang$ sudo .&#x2F;loop.py 2542 test_memory test_hello</span><br><span class="line">[*] maps: &#x2F;proc&#x2F;2542&#x2F;maps</span><br><span class="line">[*] mem: &#x2F;proc&#x2F;2542&#x2F;mem</span><br><span class="line">[*] Found [heap]:</span><br><span class="line">        pathname &#x3D; [heap]</span><br><span class="line">        addresses &#x3D; 021dc000-021fd000</span><br><span class="line">        permisions &#x3D; rw-p</span><br><span class="line">        offset &#x3D; 00000000</span><br><span class="line">        inode &#x3D; 0</span><br><span class="line">        Addr start [21dc000] | end [21fd000]</span><br><span class="line">[*] Found &#39;test_memory&#39; at 10</span><br><span class="line">[*] Writing &#39;test_hello&#39; at 21dc010</span><br></pre></td></tr></table></figure>
<p>同时字符串输出的内容也已更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[633] test_memory (0x21dc010)</span><br><span class="line">[634] test_memory (0x21dc010)</span><br><span class="line">[635] test_memory (0x21dc010)</span><br><span class="line">[636] test_memory (0x21dc010)</span><br><span class="line">[637] test_memory (0x21dc010)</span><br><span class="line">[638] test_memory (0x21dc010)</span><br><span class="line">[639] test_memory (0x21dc010)</span><br><span class="line">[640] test_helloy (0x21dc010)</span><br><span class="line">[641] test_helloy (0x21dc010)</span><br><span class="line">[642] test_helloy (0x21dc010)</span><br><span class="line">[643] test_helloy (0x21dc010)</span><br><span class="line">[644] test_helloy (0x21dc010)</span><br><span class="line">[645] test_helloy (0x21dc010)</span><br></pre></td></tr></table></figure>
<p>实验成功.</p>
<h3 id="通过实践画出虚拟内存空间分布图"><a href="#通过实践画出虚拟内存空间分布图" class="headerlink" title="通过实践画出虚拟内存空间分布图"></a>通过实践画出虚拟内存空间分布图</h3><p>再列出内存空间分布图<br><img width=350 src="/image/virtual_memory.png" ><br>基本上每个人或多或少都了解虚拟内存的空间分布，那如何验证它呢，下面会提到.</p>
<h4 id="堆栈空间"><a href="#堆栈空间" class="headerlink" title="堆栈空间"></a>堆栈空间</h4><p>首先验证栈空间的位置，我们都知道C中局部变量是存储在栈空间的，malloc分配的内存是存储在堆空间，所以可以通过打印出局部变量地址和malloc的返回内存地址的方式来验证堆栈空间在整个虚拟空间中的位置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - print locations of various elements</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    void *p;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Address of a: %p\n&quot;, (void *)&amp;a);</span><br><span class="line">    p &#x3D; malloc(98);</span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Can&#39;t malloc\n&quot;);</span><br><span class="line">        return (EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Allocated space in the heap: %p\n&quot;, p);</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行:gcc -Wall -Wextra -pedantic -Werror main.c -o test; .&#x2F;test</span><br><span class="line">输出：</span><br><span class="line">Address of a: 0x7ffedde9c7fc</span><br><span class="line">Allocated space in the heap: 0x55ca5b360670</span><br></pre></td></tr></table></figure>
<p>通过结果可以看出堆地址空间在栈地址空间下面，整理如图:<br><img width=350 src="/image/virtual_memory_stack_heap.png" >  </p>
<h4 id="可执行程序"><a href="#可执行程序" class="headerlink" title="可执行程序"></a>可执行程序</h4><p>可执行程序也在虚拟内存中，可以通过打印main函数的地址，并与堆栈地址相比较，即可知道可执行程序地址相对于堆栈地址的分布.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - print locations of various elements</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    void *p;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Address of a: %p\n&quot;, (void *)&amp;a);</span><br><span class="line">    p &#x3D; malloc(98);</span><br><span class="line">    if (p &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Can&#39;t malloc\n&quot;);</span><br><span class="line">        return (EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Allocated space in the heap: %p\n&quot;, p);</span><br><span class="line">    printf(&quot;Address of function main: %p\n&quot;, (void *)main);</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行:gcc main.c -o test; .&#x2F;test</span><br><span class="line">输出：</span><br><span class="line">Address of a: 0x7ffed846de2c</span><br><span class="line">Allocated space in the heap: 0x561b9ee8c670</span><br><span class="line">Address of function main: 0x561b9deb378a</span><br></pre></td></tr></table></figure>
<p>由于main(0x561b9deb378a) &lt; heap(0x561b9ee8c670) &lt; (0x7ffed846de2c)，可以画出分布图如下:<br><img width=350 src="/image/virtual_memory_stack_heap_executable.png" >  </p>
<h4 id="命令行参数和环境变量"><a href="#命令行参数和环境变量" class="headerlink" title="命令行参数和环境变量"></a>命令行参数和环境变量</h4><p>程序入口main函数可以携带参数:  </p>
<ul>
<li>第一个参数(argc): 命令行参数的个数</li>
<li>第二个参数(argv): 指向命令行参数数组的指针</li>
<li>第三个参数(env): 指向环境变量数组的指针</li>
</ul>
<p>通过程序可以看见这些元素在虚拟内存中的位置： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - print locations of various elements</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int ac, char **av, char **env)</span><br><span class="line">&#123;</span><br><span class="line">        int a;</span><br><span class="line">        void *p;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Address of a: %p\n&quot;, (void *)&amp;a);</span><br><span class="line">        p &#x3D; malloc(98);</span><br><span class="line">        if (p &#x3D;&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">                fprintf(stderr, &quot;Can&#39;t malloc\n&quot;);</span><br><span class="line">                return (EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Allocated space in the heap: %p\n&quot;, p);</span><br><span class="line">        printf(&quot;Address of function main: %p\n&quot;, (void *)main);</span><br><span class="line">        printf(&quot;First bytes of the main function:\n\t&quot;);</span><br><span class="line">        for (i &#x3D; 0; i &lt; 15; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;%02x &quot;, ((unsigned char *)main)[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        printf(&quot;Address of the array of arguments: %p\n&quot;, (void *)av);</span><br><span class="line">        printf(&quot;Addresses of the arguments:\n\t&quot;);</span><br><span class="line">        for (i &#x3D; 0; i &lt; ac; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;[%s]:%p &quot;, av[i], av[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        printf(&quot;Address of the array of environment variables: %p\n&quot;, (void *)env);</span><br><span class="line">    printf(&quot;Address of the first environment variable: %p\n&quot;, (void *)(env[0]));</span><br><span class="line">        return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行:gcc main.c -o test; .&#x2F;test nihao hello</span><br><span class="line">输出：</span><br><span class="line">Address of a: 0x7ffcc154a748</span><br><span class="line">Allocated space in the heap: 0x559bd1bee670</span><br><span class="line">Address of function main: 0x559bd09807ca</span><br><span class="line">First bytes of the main function:</span><br><span class="line">        55 48 89 e5 48 83 ec 40 89 7d dc 48 89 75 d0</span><br><span class="line">Address of the array of arguments: 0x7ffcc154a848</span><br><span class="line">Addresses of the arguments:</span><br><span class="line">        [.&#x2F;test]:0x7ffcc154b94f [nihao]:0x7ffcc154b956 [hello]:0x7ffcc154b95c</span><br><span class="line">Address of the array of environment variables: 0x7ffcc154a868</span><br><span class="line">Address of the first environment variable: 0x7ffcc154b962</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>main(0x559bd09807ca) &lt; heap(0x559bd1bee670) &lt; stack(0x7ffcc154a748) &lt; argv(0x7ffcc154a848) &lt; env(0x7ffcc154a868) &lt; arguments(0x7ffcc154b94f-&gt;0x7ffcc154b95c + 6)(6为hello+1(‘\0’)) &lt; env first(0x7ffcc154b962)<br>可以看出所有的命令行参数都是相邻的，并且紧接着就是环境变量.</p>
<h4 id="argv和env数组地址是相邻的吗"><a href="#argv和env数组地址是相邻的吗" class="headerlink" title="argv和env数组地址是相邻的吗"></a>argv和env数组地址是相邻的吗</h4><p>上例中argv有4个元素，命令行中有三个参数，还有一个NULL指向标记数组的末尾，每个指针是8字节，8*4=32, argv(0x7ffcc154a848) + 32(0x20) = env(0x7ffcc154a868)，所以argv和env数组指针是相邻的.</p>
<h4 id="命令行参数地址紧随环境变量地址之后吗"><a href="#命令行参数地址紧随环境变量地址之后吗" class="headerlink" title="命令行参数地址紧随环境变量地址之后吗"></a>命令行参数地址紧随环境变量地址之后吗</h4><p>首先需要获取环境变量数组的大小，环境变量数组是以NULL结束的，所以可以遍历env数组，检查是否为NULL，获取数组大小，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**                                                                                                      </span><br><span class="line"> * main - print locations of various elements                                                            </span><br><span class="line"> *                                                                                                       </span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS                                      </span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(int ac, char **av, char **env)</span><br><span class="line">&#123;</span><br><span class="line">     int a;</span><br><span class="line">     void *p;</span><br><span class="line">     int i;</span><br><span class="line">     int size;</span><br><span class="line"></span><br><span class="line">     printf(&quot;Address of a: %p\n&quot;, (void *)&amp;a);</span><br><span class="line">     p &#x3D; malloc(98);</span><br><span class="line">     if (p &#x3D;&#x3D; NULL)</span><br><span class="line">     &#123;</span><br><span class="line">          fprintf(stderr, &quot;Can&#39;t malloc\n&quot;);</span><br><span class="line">          return (EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;Allocated space in the heap: %p\n&quot;, p);</span><br><span class="line">     printf(&quot;Address of function main: %p\n&quot;, (void *)main);</span><br><span class="line">     printf(&quot;First bytes of the main function:\n\t&quot;);</span><br><span class="line">     for (i &#x3D; 0; i &lt; 15; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          printf(&quot;%02x &quot;, ((unsigned char *)main)[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line">     printf(&quot;Address of the array of arguments: %p\n&quot;, (void *)av);</span><br><span class="line">     printf(&quot;Addresses of the arguments:\n\t&quot;);</span><br><span class="line">     for (i &#x3D; 0; i &lt; ac; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          printf(&quot;[%s]:%p &quot;, av[i], av[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line">     printf(&quot;Address of the array of environment variables: %p\n&quot;, (void *)env);</span><br><span class="line">     printf(&quot;Address of the first environment variables:\n&quot;);</span><br><span class="line">     for (i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">     &#123;</span><br><span class="line">          printf(&quot;\t[%p]:\&quot;%s\&quot;\n&quot;, env[i], env[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;* size of the env array *&#x2F;</span><br><span class="line">     i &#x3D; 0;</span><br><span class="line">     while (env[i] !&#x3D; NULL)</span><br><span class="line">     &#123;</span><br><span class="line">          i++;</span><br><span class="line">     &#125;</span><br><span class="line">     i++; &#x2F;* the NULL pointer *&#x2F;</span><br><span class="line">     size &#x3D; i * sizeof(char *);</span><br><span class="line">     printf(&quot;Size of the array env: %d elements -&gt; %d bytes (0x%x)\n&quot;, i, size, size);</span><br><span class="line">     return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译运行:gcc main.c -o test; .&#x2F;test nihao hello</span><br><span class="line">输出：</span><br><span class="line">Address of a: 0x7ffd5ebadff4</span><br><span class="line">Allocated space in the heap: 0x562ba4e13670</span><br><span class="line">Address of function main: 0x562ba2f1881a</span><br><span class="line">First bytes of the main function:</span><br><span class="line">        55 48 89 e5 48 83 ec 40 89 7d dc 48 89 75 d0</span><br><span class="line">Address of the array of arguments: 0x7ffd5ebae0f8</span><br><span class="line">Addresses of the arguments:</span><br><span class="line">        [.&#x2F;test]:0x7ffd5ebae94f [nihao]:0x7ffd5ebae956 [hello]:0x7ffd5ebae95c</span><br><span class="line">Address of the array of environment variables: 0x7ffd5ebae118</span><br><span class="line">Address of the first environment variables:</span><br><span class="line">        [0x7ffd5ebae962]:&quot;LS_COLORS&#x3D;rs&#x3D;0:di&#x3D;01;34:ln&#x3D;01;36:mh&#x3D;00:pi&#x3D;40;33:so&#x3D;01;35:do&#x3D;01;35:bd&#x3D;40;33;01:cd&#x3D;40;33;01:or&#x3D;40;31;01:mi&#x3D;00:su&#x3D;37;41:sg&#x3D;30;43:ca&#x3D;30;41:tw&#x3D;30;42:ow&#x3D;34;42:st&#x3D;37;44:ex&#x3D;01;32:*.tar&#x3D;01;31:*.tgz&#x3D;01;31:*.arc&#x3D;01;31:*.arj&#x3D;01;31:*.taz&#x3D;01;31:*.lha&#x3D;01;31:*.lz4&#x3D;01;31:*.lzh&#x3D;01;31:*.lzma&#x3D;01;31:*.tlz&#x3D;01;31:*.txz&#x3D;01;31:*.tzo&#x3D;01;31:*.t7z&#x3D;01;31:*.zip&#x3D;01;31:*.z&#x3D;01;31:*.Z&#x3D;01;31:*.dz&#x3D;01;31:*.gz&#x3D;01;31:*.lrz&#x3D;01;31:*.lz&#x3D;01;31:*.lzo&#x3D;01;31:*.xz&#x3D;01;31:*.zst&#x3D;01;31:*.tzst&#x3D;01;31:*.bz2&#x3D;01;31:*.bz&#x3D;01;31:*.tbz&#x3D;01;31:*.tbz2&#x3D;01;31:*.tz&#x3D;01;31:*.deb&#x3D;01;31:*.rpm&#x3D;01;31:*.jar&#x3D;01;31:*.war&#x3D;01;31:*.ear&#x3D;01;31:*.sar&#x3D;01;31:*.rar&#x3D;01;31:*.alz&#x3D;01;31:*.ace&#x3D;01;31:*.zoo&#x3D;01;31:*.cpio&#x3D;01;31:*.7z&#x3D;01;31:*.rz&#x3D;01;31:*.cab&#x3D;01;31:*.wim&#x3D;01;31:*.swm&#x3D;01;31:*.dwm&#x3D;01;31:*.esd&#x3D;01;31:*.jpg&#x3D;01;35:*.jpeg&#x3D;01;35:*.mjpg&#x3D;01;35:*.mjpeg&#x3D;01;35:*.gif&#x3D;01;35:*.bmp&#x3D;01;35:*.pbm&#x3D;01;35:*.pgm&#x3D;01;35:*.ppm&#x3D;01;35:*.tga&#x3D;01;35:*.xbm&#x3D;01;35:*.xpm&#x3D;01;35:*.tif&#x3D;01;35:*.tiff&#x3D;01;35:*.png&#x3D;01;35:*.svg&#x3D;01;35:*.svgz&#x3D;01;35:*.mng&#x3D;01;35:*.pcx&#x3D;01;35:*.mov&#x3D;01;35:*.mpg&#x3D;01;35:*.mpeg&#x3D;01;35:*.m2v&#x3D;01;35:*.mkv&#x3D;01;35:*.webm&#x3D;01;35:*.ogm&#x3D;01;35:*.mp4&#x3D;01;35:*.m4v&#x3D;01;35:*.mp4v&#x3D;01;35:*.vob&#x3D;01;35:*.qt&#x3D;01;35:*.nuv&#x3D;01;35:*.wmv&#x3D;01;35:*.asf&#x3D;01;35:*.rm&#x3D;01;35:*.rmvb&#x3D;01;35:*.flc&#x3D;01;35:*.avi&#x3D;01;35:*.fli&#x3D;01;35:*.flv&#x3D;01;35:*.gl&#x3D;01;35:*.dl&#x3D;01;35:*.xcf&#x3D;01;35:*.xwd&#x3D;01;35:*.yuv&#x3D;01;35:*.cgm&#x3D;01;35:*.emf&#x3D;01;35:*.ogv&#x3D;01;35:*.ogx&#x3D;01;35:*.aac&#x3D;00;36:*.au&#x3D;00;36:*.flac&#x3D;00;36:*.m4a&#x3D;00;36:*.mid&#x3D;00;36:*.midi&#x3D;00;36:*.mka&#x3D;00;36:*.mp3&#x3D;00;36:*.mpc&#x3D;00;36:*.ogg&#x3D;00;36:*.ra&#x3D;00;36:*.wav&#x3D;00;36:*.oga&#x3D;00;36:*.opus&#x3D;00;36:*.spx&#x3D;00;36:*.xspf&#x3D;00;36:&quot;</span><br><span class="line">        [0x7ffd5ebaef4e]:&quot;HOSTNAME&#x3D;3e8650948c0c&quot;</span><br><span class="line">        [0x7ffd5ebaef64]:&quot;OLDPWD&#x3D;&#x2F;&quot;</span><br><span class="line">Size of the array env: 11 elements -&gt; 88 bytes (0x58)</span><br><span class="line"></span><br><span class="line">运算结果如下：</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# bc</span><br><span class="line">bc 1.07.1</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type &#96;warranty&#39;.</span><br><span class="line">obase&#x3D;16</span><br><span class="line">ibase&#x3D;16</span><br><span class="line">58+7ffd5ebae118</span><br><span class="line">(standard_in) 3: syntax error</span><br><span class="line">58+7FFD5EBAE118</span><br><span class="line">7FFD5EBAE170</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
<p>通过结果可知7FFD5EBAE170 != 0x7ffd5ebae94f，所以命令行参数地址不是紧随环境变量地址之后。<br>截至目前画出图表如下：<br><img width=350 src="/image/virtual_memory_args_env.png" >  </p>
<h4 id="栈内存真的向下增长吗"><a href="#栈内存真的向下增长吗" class="headerlink" title="栈内存真的向下增长吗"></a>栈内存真的向下增长吗</h4><p>可以通过调用函数来确认，如果真的是向下增长，那么调用函数的地址应该高于被调用函数地址, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void f(void)</span><br><span class="line">&#123;</span><br><span class="line">     int a;</span><br><span class="line">     int b;</span><br><span class="line">     int c;</span><br><span class="line"></span><br><span class="line">     a &#x3D; 98;</span><br><span class="line">     b &#x3D; 1024;</span><br><span class="line">     c &#x3D; a * b;</span><br><span class="line">     printf(&quot;[f] a &#x3D; %d, b &#x3D; %d, c &#x3D; a * b &#x3D; %d\n&quot;, a, b, c);</span><br><span class="line">     printf(&quot;[f] Adresses of a: %p, b &#x3D; %p, c &#x3D; %p\n&quot;, (void *)&amp;a, (void *)&amp;b, (void *)&amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int ac, char **av, char **env)</span><br><span class="line">&#123;</span><br><span class="line">     int a;</span><br><span class="line">     void *p;</span><br><span class="line">     int i;</span><br><span class="line">     int size;</span><br><span class="line"></span><br><span class="line">     printf(&quot;Address of a: %p\n&quot;, (void *)&amp;a);</span><br><span class="line">     p &#x3D; malloc(98);</span><br><span class="line">     if (p &#x3D;&#x3D; NULL)</span><br><span class="line">     &#123;</span><br><span class="line">          fprintf(stderr, &quot;Can&#39;t malloc\n&quot;);</span><br><span class="line">          return (EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line">     printf(&quot;Allocated space in the heap: %p\n&quot;, p);</span><br><span class="line">     printf(&quot;Address of function main: %p\n&quot;, (void *)main);</span><br><span class="line">     f();</span><br><span class="line">     return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行:gcc main.c -o test; .&#x2F;test</span><br><span class="line">输出：</span><br><span class="line">Address of a: 0x7ffefc75083c</span><br><span class="line">Allocated space in the heap: 0x564d46318670</span><br><span class="line">Address of function main: 0x564d45b9880e</span><br><span class="line">[f] a &#x3D; 98, b &#x3D; 1024, c &#x3D; a * b &#x3D; 100352</span><br><span class="line">[f] Adresses of a: 0x7ffefc7507ec, b &#x3D; 0x7ffefc7507f0, c &#x3D; 0x7ffefc7507f4</span><br></pre></td></tr></table></figure>
<p>结果可知: f{a} 0x7ffefc7507ec &lt; main{a} 0x7ffefc75083c<br>可画图如下：<br><img width=350 src="/image/virtual_memory_stack.png" >   </p>
<p>其实也可以写一个简单的代码，通过查看/proc文件系统中map内容来查看内存分布，这里就不举例啦.  </p>
<h3 id="堆内存-malloc"><a href="#堆内存-malloc" class="headerlink" title="堆内存(malloc)"></a>堆内存(malloc)</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>malloc是常用的动态分配内存的函数，malloc申请的内存分配在堆中，注意malloc是glibc函数，不是系统调用.<br>man malloc:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...] allocate dynamic memory[...]</span><br><span class="line">void *malloc(size_t size);</span><br><span class="line">[...]</span><br><span class="line">The malloc() function allocates size bytes and returns a pointer to the allocated memory.</span><br></pre></td></tr></table></figure>

<h4 id="不调用malloc，就不会有堆空间-heap"><a href="#不调用malloc，就不会有堆空间-heap" class="headerlink" title="不调用malloc，就不会有堆空间[heap]"></a>不调用malloc，就不会有堆空间[heap]</h4><p>看一段不调用malloc的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - do nothing</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    getchar();</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行：gcc test.c -o 2; .&#x2F;2</span><br><span class="line">step 1 : ps aux | grep \ \.&#x2F;2$</span><br><span class="line">输出：</span><br><span class="line">zjucad    3023  0.0  0.0   4352   788 pts&#x2F;3    S+   13:58   0:00 .&#x2F;2</span><br><span class="line">step 2 : &#x2F;proc&#x2F;3023&#x2F;maps</span><br><span class="line">输出：</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 811723                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;2</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 811723                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;2</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 811723                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;2</span><br><span class="line">007a4000-007c5000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7f954ca02000-7f954cbc2000 r-xp 00000000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f954cbc2000-7f954cdc2000 ---p 001c0000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f954cdc2000-7f954cdc6000 r--p 001c0000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f954cdc6000-7f954cdc8000 rw-p 001c4000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f954cdc8000-7f954cdcc000 rw-p 00000000 00:00 0</span><br><span class="line">7f954cdcc000-7f954cdf2000 r-xp 00000000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f954cfd2000-7f954cfd5000 rw-p 00000000 00:00 0</span><br><span class="line">7f954cff1000-7f954cff2000 r--p 00025000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f954cff2000-7f954cff3000 rw-p 00026000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f954cff3000-7f954cff4000 rw-p 00000000 00:00 0</span><br><span class="line">7ffed68a1000-7ffed68c2000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffed690e000-7ffed6911000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffed6911000-7ffed6913000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>可以看到，如果不调用malloc，maps中就没有[heap]  </p>
<p>下面运行一个带有malloc的程序  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - prints the malloc returned address</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line"></span><br><span class="line">    p &#x3D; malloc(1);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line">    getchar();</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行：gcc test.c -o 3; .&#x2F;3</span><br><span class="line">输出：0xcc7010</span><br><span class="line">验证步骤及输出：</span><br><span class="line">zjucad@zjucad-ONDA-H110-MINI-V3-01:~&#x2F;wangzhiqiang$ ps aux | grep \ \.&#x2F;3$</span><br><span class="line">zjucad    3113  0.0  0.0   4352   644 pts&#x2F;3    S+   14:06   0:00 .&#x2F;3</span><br><span class="line">zjucad@zjucad-ONDA-H110-MINI-V3-01:~&#x2F;wangzhiqiang$ cat &#x2F;proc&#x2F;3113&#x2F;maps</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 811726                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;3</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 811726                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;3</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 811726                             &#x2F;home&#x2F;zjucad&#x2F;wangzhiqiang&#x2F;3</span><br><span class="line">00cc7000-00ce8000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7fc7e9128000-7fc7e92e8000 r-xp 00000000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fc7e92e8000-7fc7e94e8000 ---p 001c0000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fc7e94e8000-7fc7e94ec000 r--p 001c0000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fc7e94ec000-7fc7e94ee000 rw-p 001c4000 08:01 8661324                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fc7e94ee000-7fc7e94f2000 rw-p 00000000 00:00 0</span><br><span class="line">7fc7e94f2000-7fc7e9518000 r-xp 00000000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7fc7e96f8000-7fc7e96fb000 rw-p 00000000 00:00 0</span><br><span class="line">7fc7e9717000-7fc7e9718000 r--p 00025000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7fc7e9718000-7fc7e9719000 rw-p 00026000 08:01 8661310                    &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7fc7e9719000-7fc7e971a000 rw-p 00000000 00:00 0</span><br><span class="line">7ffc91c18000-7ffc91c39000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffc91d5f000-7ffc91d62000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffc91d62000-7ffc91d64000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>程序中带有malloc，那maps中就有[heap]段，并且malloc返回的地址在heap的地址段中，但是返回的地址却不再heap的最开始地址上，相差了0x10字节，为什么呢?看下面：</p>
<h4 id="strace-brk-sbrk"><a href="#strace-brk-sbrk" class="headerlink" title="strace, brk, sbrk"></a>strace, brk, sbrk</h4><p>malloc不是系统调用，它是一个正常函数，它必须调用某些系统调用才可以操作堆内存，通过使用strace工具可以追踪进程的系统调用和信号，为了确认系统调用是malloc产生的，所以在malloc前后添加write系统调用方便定位问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - let&#39;s find out which syscall malloc is using</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line"></span><br><span class="line">    write(1, &quot;BEFORE MALLOC\n&quot;, 14);</span><br><span class="line">    p &#x3D; malloc(1);</span><br><span class="line">    write(1, &quot;AFTER MALLOC\n&quot;, 13);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line">    getchar();</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行：gcc test.c -o 4</span><br><span class="line">zjucad@zjucad-ONDA-H110-MINI-V3-01:~&#x2F;wangzhiqiang$ strace .&#x2F;4</span><br><span class="line">execve(&quot;.&#x2F;4&quot;, [&quot;.&#x2F;4&quot;], [&#x2F;* 34 vars *&#x2F;]) &#x3D; 0</span><br><span class="line">brk(NULL)                               &#x3D; 0x781000</span><br><span class="line">access(&quot;&#x2F;etc&#x2F;ld.so.nohwcap&quot;, F_OK)      &#x3D; -1 ENOENT (No such file or directory)</span><br><span class="line">access(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;, R_OK)      &#x3D; -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;&#x2F;etc&#x2F;ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) &#x3D; 3</span><br><span class="line">fstat(3, &#123;st_mode&#x3D;S_IFREG|0644, st_size&#x3D;111450, ...&#125;) &#x3D; 0</span><br><span class="line">mmap(NULL, 111450, PROT_READ, MAP_PRIVATE, 3, 0) &#x3D; 0x7f37720fa000</span><br><span class="line">close(3)                                &#x3D; 0</span><br><span class="line">access(&quot;&#x2F;etc&#x2F;ld.so.nohwcap&quot;, F_OK)      &#x3D; -1 ENOENT (No such file or directory)</span><br><span class="line">open(&quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;, O_RDONLY|O_CLOEXEC) &#x3D; 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\t\2\0\0\0\0\0&quot;..., 832) &#x3D; 832</span><br><span class="line">fstat(3, &#123;st_mode&#x3D;S_IFREG|0755, st_size&#x3D;1868984, ...&#125;) &#x3D; 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) &#x3D; 0x7f37720f9000</span><br><span class="line">mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) &#x3D; 0x7f3771b27000</span><br><span class="line">mprotect(0x7f3771ce7000, 2097152, PROT_NONE) &#x3D; 0</span><br><span class="line">mmap(0x7f3771ee7000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) &#x3D; 0x7f3771ee7000</span><br><span class="line">mmap(0x7f3771eed000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) &#x3D; 0x7f3771eed000</span><br><span class="line">close(3)                                &#x3D; 0</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) &#x3D; 0x7f37720f8000</span><br><span class="line">mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) &#x3D; 0x7f37720f7000</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7f37720f8700) &#x3D; 0</span><br><span class="line">mprotect(0x7f3771ee7000, 16384, PROT_READ) &#x3D; 0</span><br><span class="line">mprotect(0x600000, 4096, PROT_READ)     &#x3D; 0</span><br><span class="line">mprotect(0x7f3772116000, 4096, PROT_READ) &#x3D; 0</span><br><span class="line">munmap(0x7f37720fa000, 111450)          &#x3D; 0</span><br><span class="line">write(1, &quot;BEFORE MALLOC\n&quot;, 14BEFORE MALLOC</span><br><span class="line">)         &#x3D; 14</span><br><span class="line">brk(NULL)                               &#x3D; 0x781000</span><br><span class="line">brk(0x7a2000)                           &#x3D; 0x7a2000</span><br><span class="line">write(1, &quot;AFTER MALLOC\n&quot;, 13AFTER MALLOC</span><br><span class="line">)          &#x3D; 13</span><br><span class="line">fstat(1, &#123;st_mode&#x3D;S_IFCHR|0620, st_rdev&#x3D;makedev(136, 3), ...&#125;) &#x3D; 0</span><br><span class="line">write(1, &quot;0x781010\n&quot;, 90x781010</span><br><span class="line">)               &#x3D; 9</span><br><span class="line">fstat(0, &#123;st_mode&#x3D;S_IFCHR|0620, st_rdev&#x3D;makedev(136, 3), ...&#125;) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>最后几行的输出可知，malloc主要调用brk系统调用来操作堆内存.  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man brk</span><br><span class="line">...</span><br><span class="line">       int brk(void *addr);</span><br><span class="line">       void *sbrk(intptr_t increment);</span><br><span class="line">...</span><br><span class="line">DESCRIPTION</span><br><span class="line">       brk() and sbrk() change the location of the program  break,  which  defines</span><br><span class="line">       the end of the process&#39;s data segment (i.e., the program break is the first</span><br><span class="line">       location after the end of the uninitialized data segment).  Increasing  the</span><br><span class="line">       program  break has the effect of allocating memory to the process; decreas‐</span><br><span class="line">       ing the break deallocates memory.</span><br><span class="line"></span><br><span class="line">       brk() sets the end of the data segment to the value specified by addr, when</span><br><span class="line">       that  value  is  reasonable,  the system has enough memory, and the process</span><br><span class="line">       does not exceed its maximum data size (see setrlimit(2)).</span><br><span class="line"></span><br><span class="line">       sbrk() increments the program&#39;s data space  by  increment  bytes.   Calling</span><br><span class="line">       sbrk()  with  an increment of 0 can be used to find the current location of</span><br><span class="line">       the program break.</span><br></pre></td></tr></table></figure>
<p>程序中断是虚拟内存中程序数据段结束后的第一个位置的地址，malloc通过调用brk或者sbrk，增加程序中断的值就可以创建新空间来动态分配内存，首次调用brk会返回当前程序中断的地址，第二次调用brk也会返回程序中断的地址，可以发现第二次brk返回地址大于第一次brk返回地址，brk就是通过增加程序中断地址的方式来分配内存，可以看出现在的堆地址范围是0x781000-0x7a2000，通过cat /proc/[pid]/maps也可以验证，此处就不贴上实际验证的结果啦。</p>
<h4 id="多次malloc"><a href="#多次malloc" class="headerlink" title="多次malloc"></a>多次malloc</h4><p>如果多次malloc会出现什么现象呢，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - many calls to malloc</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line"></span><br><span class="line">    write(1, &quot;BEFORE MALLOC #0\n&quot;, 17);</span><br><span class="line">    p &#x3D; malloc(1024);</span><br><span class="line">    write(1, &quot;AFTER MALLOC #0\n&quot;, 16);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line"></span><br><span class="line">    write(1, &quot;BEFORE MALLOC #1\n&quot;, 17);</span><br><span class="line">    p &#x3D; malloc(1024);</span><br><span class="line">    write(1, &quot;AFTER MALLOC #1\n&quot;, 16);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line"></span><br><span class="line">    write(1, &quot;BEFORE MALLOC #2\n&quot;, 17);</span><br><span class="line">    p &#x3D; malloc(1024);</span><br><span class="line">    write(1, &quot;AFTER MALLOC #2\n&quot;, 16);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line"></span><br><span class="line">    write(1, &quot;BEFORE MALLOC #3\n&quot;, 17);</span><br><span class="line">    p &#x3D; malloc(1024);</span><br><span class="line">    write(1, &quot;AFTER MALLOC #3\n&quot;, 16);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行：gcc test.c -o 5; strace .&#x2F;5</span><br><span class="line">摘要输出结果如下：</span><br><span class="line">write(1, &quot;BEFORE MALLOC #0\n&quot;, 17BEFORE MALLOC #0</span><br><span class="line">)      &#x3D; 17</span><br><span class="line">brk(NULL)                               &#x3D; 0x561605c7a000</span><br><span class="line">brk(0x561605c9b000)                     &#x3D; 0x561605c9b000</span><br><span class="line">write(1, &quot;AFTER MALLOC #0\n&quot;, 16AFTER MALLOC #0</span><br><span class="line">)       &#x3D; 16</span><br><span class="line">fstat(1, &#123;st_mode&#x3D;S_IFCHR|0620, st_rdev&#x3D;makedev(136, 0), ...&#125;) &#x3D; 0</span><br><span class="line">write(1, &quot;0x561605c7a260\n&quot;, 150x561605c7a260</span><br><span class="line">)        &#x3D; 15</span><br><span class="line">write(1, &quot;BEFORE MALLOC #1\n&quot;, 17BEFORE MALLOC #1</span><br><span class="line">)      &#x3D; 17</span><br><span class="line">write(1, &quot;AFTER MALLOC #1\n&quot;, 16AFTER MALLOC #1</span><br><span class="line">)       &#x3D; 16</span><br><span class="line">write(1, &quot;0x561605c7aa80\n&quot;, 150x561605c7aa80</span><br><span class="line">)        &#x3D; 15</span><br><span class="line">write(1, &quot;BEFORE MALLOC #2\n&quot;, 17BEFORE MALLOC #2</span><br><span class="line">)      &#x3D; 17</span><br><span class="line">write(1, &quot;AFTER MALLOC #2\n&quot;, 16AFTER MALLOC #2</span><br><span class="line">)       &#x3D; 16</span><br><span class="line">write(1, &quot;0x561605c7ae90\n&quot;, 150x561605c7ae90</span><br><span class="line">)        &#x3D; 15</span><br><span class="line">write(1, &quot;BEFORE MALLOC #3\n&quot;, 17BEFORE MALLOC #3</span><br><span class="line">)      &#x3D; 17</span><br><span class="line">write(1, &quot;AFTER MALLOC #3\n&quot;, 16AFTER MALLOC #3</span><br><span class="line">)       &#x3D; 16</span><br><span class="line">write(1, &quot;0x561605c7b2a0\n&quot;, 150x561605c7b2a0</span><br><span class="line">)        &#x3D; 15</span><br><span class="line">fstat(0, &#123;st_mode&#x3D;S_IFCHR|0620, st_rdev&#x3D;makedev(136, 0), ...&#125;) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>可以发现并不是每次调用malloc都会触发brk系统调用，首次调用malloc，内部会通过brk系统调用更改程序中断地址，分配出一大块内存空间，后续再调用malloc，malloc内部会优先使用之前分配出来的内存空间，直到内部内存空间已经不够再次分配给外部时才会再次触发brk系统调用.</p>
<h4 id="0x10-那丢失的16字节是什么"><a href="#0x10-那丢失的16字节是什么" class="headerlink" title="0x10 那丢失的16字节是什么"></a>0x10 那丢失的16字节是什么</h4><p>上面分析可以看见程序第一次调用malloc返回的地址并不是heap段的首地址，而是相差了0x10个字节，那这16个字节究竟是什么，可以通过程序打印出这前16个字节的内容.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">编译运行：gcc test.c -o test;.&#x2F;test</span><br><span class="line">输出：</span><br><span class="line">0x5589436ce260</span><br><span class="line">bytes at 0x5589436ce250:</span><br><span class="line">00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00</span><br><span class="line">0x5589436cea80</span><br><span class="line">bytes at 0x5589436cea70:</span><br><span class="line">00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00</span><br><span class="line">0x5589436cf290</span><br><span class="line">bytes at 0x5589436cf280:</span><br><span class="line">00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00</span><br><span class="line">0x5589436cfea0</span><br><span class="line">bytes at 0x5589436cfe90:</span><br><span class="line">00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00</span><br><span class="line">0x5589436d0eb0</span><br><span class="line">bytes at 0x5589436d0ea0:</span><br><span class="line">00 00 00 00 00 00 00 00 11 14 00 00 00 00 00 00</span><br><span class="line">0x5589436d22c0</span><br><span class="line">bytes at 0x5589436d22b0:</span><br><span class="line">00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00</span><br><span class="line">0x5589436d3ad0</span><br><span class="line">bytes at 0x5589436d3ac0:</span><br><span class="line">00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00</span><br><span class="line">0x5589436d56e0</span><br><span class="line">bytes at 0x5589436d56d0:</span><br><span class="line">00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00</span><br><span class="line">0x5589436d76f0</span><br><span class="line">bytes at 0x5589436d76e0:</span><br><span class="line">00 00 00 00 00 00 00 00 11 24 00 00 00 00 00 00</span><br><span class="line">0x5589436d9b00</span><br><span class="line">bytes at 0x5589436d9af0:</span><br><span class="line">00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>可以看出规律：这16个字节相当于malloc出来的地址的头，包含一些信息，目前可以看出它包括已经分配的地址空间的大小，第一次malloc申请了0x400(1024)字节，可以发现11 04 00 00 00 00 00 00大于0x400(1024)，这8个字节表示数字 0x 00 00 00 00 00 00 04 11 = 0x400(1024) + 0x10(头的大小16) + 1(后面会说明它的含义)，可以发现每次调用malloc，这前8个字节代表的含义都是malloc字节数+16+1.<br>可以猜测，malloc内部会把这前16个字节强转成某种数据结构，数据结构包含某些信息，最主要的是已经分配的字节数，尽管我们不了解具体结构，但是也可以通过代码操作这16个字节验证我们上面总结的规律是否正确，注意代码中不调用free释放内存.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**                                                                </span><br><span class="line"> * pmem - print mem                                                </span><br><span class="line"> * @p: memory address to start printing from                       </span><br><span class="line"> * @bytes: number of bytes to print                                </span><br><span class="line"> *                                                                 </span><br><span class="line"> * Return: nothing</span><br><span class="line"> *&#x2F;</span><br><span class="line">void pmem(void *p, unsigned int bytes)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *ptr;</span><br><span class="line">    unsigned int i;</span><br><span class="line"></span><br><span class="line">    ptr &#x3D; (unsigned char *)p;</span><br><span class="line">    for (i &#x3D; 0; i &lt; bytes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%02x&quot;, *(ptr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - confirm the source code</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line">    int i;</span><br><span class="line">    size_t size_of_the_chunk;</span><br><span class="line">    size_t size_of_the_previous_chunk;</span><br><span class="line">    void *chunks[10];</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; malloc(1024 * (i + 1));</span><br><span class="line">        chunks[i] &#x3D; (void *)((char *)p - 0x10);</span><br><span class="line">        printf(&quot;%p\n&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">    free((char *)(chunks[3]) + 0x10);</span><br><span class="line">    free((char *)(chunks[7]) + 0x10);</span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; chunks[i];</span><br><span class="line">        printf(&quot;chunks[%d]: &quot;, i);</span><br><span class="line">        pmem(p, 0x10);</span><br><span class="line">        size_of_the_chunk &#x3D; *((size_t *)((char *)p + 8)) - 1;</span><br><span class="line">        size_of_the_previous_chunk &#x3D; *((size_t *)((char *)p));</span><br><span class="line">        printf(&quot;chunks[%d]: %p, size &#x3D; %li, prev &#x3D; %li\n&quot;,</span><br><span class="line">              i, p, size_of_the_chunk, size_of_the_previous_chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行输出：</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# gcc test.c -o test</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# .&#x2F;test</span><br><span class="line">0x559721de4260</span><br><span class="line">0x559721de4a80</span><br><span class="line">0x559721de5290</span><br><span class="line">0x559721de5ea0</span><br><span class="line">0x559721de6eb0</span><br><span class="line">0x559721de82c0</span><br><span class="line">0x559721de9ad0</span><br><span class="line">0x559721deb6e0</span><br><span class="line">0x559721ded6f0</span><br><span class="line">0x559721defb00</span><br><span class="line">chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00</span><br><span class="line">chunks[0]: 0x559721de4250, size &#x3D; 1040, prev &#x3D; 0</span><br><span class="line">chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00</span><br><span class="line">chunks[1]: 0x559721de4a70, size &#x3D; 2064, prev &#x3D; 0</span><br><span class="line">chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00</span><br><span class="line">chunks[2]: 0x559721de5280, size &#x3D; 3088, prev &#x3D; 0</span><br><span class="line">chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00</span><br><span class="line">chunks[3]: 0x559721de5e90, size &#x3D; 4112, prev &#x3D; 0</span><br><span class="line">chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00</span><br><span class="line">chunks[4]: 0x559721de6ea0, size &#x3D; 5135, prev &#x3D; 4112</span><br><span class="line">chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00</span><br><span class="line">chunks[5]: 0x559721de82b0, size &#x3D; 6160, prev &#x3D; 0</span><br><span class="line">chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00</span><br><span class="line">chunks[6]: 0x559721de9ac0, size &#x3D; 7184, prev &#x3D; 0</span><br><span class="line">chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00</span><br><span class="line">chunks[7]: 0x559721deb6d0, size &#x3D; 8208, prev &#x3D; 0</span><br><span class="line">chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00</span><br><span class="line">chunks[8]: 0x559721ded6e0, size &#x3D; 9231, prev &#x3D; 8208</span><br><span class="line">chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00</span><br><span class="line">chunks[9]: 0x559721defaf0, size &#x3D; 10256, prev &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>结果可以看出，malloc返回的地址往前的16个字节可以表示已经分配的内存大小, 如图：<br><img width=350 src="/image/0x10-malloc.png" >   </p>
<p>注意上述是没有调用free释放内存的结果，然而malloc只用了8个字节表示已经分配的内存大小，那么另外8个字节被用来表示什么含义呢，看下malloc函数的注释:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1055 &#x2F;*</span><br><span class="line">1056       malloc_chunk details:</span><br><span class="line">1057    </span><br><span class="line">1058        (The following includes lightly edited explanations by Colin Plumb.)</span><br><span class="line">1059    </span><br><span class="line">1060        Chunks of memory are maintained using a &#96;boundary tag&#39; method as</span><br><span class="line">1061        described in e.g., Knuth or Standish.  (See the paper by Paul</span><br><span class="line">1062        Wilson ftp:&#x2F;&#x2F;ftp.cs.utexas.edu&#x2F;pub&#x2F;garbage&#x2F;allocsrv.ps for a</span><br><span class="line">1063        survey of such techniques.)  Sizes of free chunks are stored both</span><br><span class="line">1064        in the front of each chunk and at the end.  This makes</span><br><span class="line">1065        consolidating fragmented chunks into bigger chunks very fast.  The</span><br><span class="line">1066        size fields also hold bits representing whether chunks are free or</span><br><span class="line">1067        in use.</span><br><span class="line">1068    </span><br><span class="line">1069        An allocated chunk looks like this:</span><br><span class="line">1070    </span><br><span class="line">1071    </span><br><span class="line">1072        chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1073                |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">1074                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1075                |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">1076          mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1077                |             User data starts here...                          .</span><br><span class="line">1078                .                                                               .</span><br><span class="line">1079                .             (malloc_usable_size() bytes)                      .</span><br><span class="line">1080                .                                                               |</span><br><span class="line">1081    nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1082                |             (size of chunk, but used for application data)    |</span><br><span class="line">1083                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1084                |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">1085                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">1086    </span><br><span class="line">1087        Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span><br><span class="line">1088        the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span><br><span class="line">1089        user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span><br></pre></td></tr></table></figure>
<p>可以看出这16字节有两个含义，前8个字节表示之前的空间有多少没有被分配的字节大小，后8个字节表示当前malloc已经分配的字节大小，通过一段调用free的代码查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**                                                                                            </span><br><span class="line"> * pmem - print mem                                                                            </span><br><span class="line"> * @p: memory address to start printing from                                                   </span><br><span class="line"> * @bytes: number of bytes to print                                                            </span><br><span class="line"> *                                                                                             </span><br><span class="line"> * Return: nothing                                                                             </span><br><span class="line"> *&#x2F;</span><br><span class="line">void pmem(void *p, unsigned int bytes)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *ptr;</span><br><span class="line">    unsigned int i;</span><br><span class="line"></span><br><span class="line">    ptr &#x3D; (unsigned char *)p;</span><br><span class="line">    for (i &#x3D; 0; i &lt; bytes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%02x&quot;, *(ptr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - confirm the source code</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line">    int i;</span><br><span class="line">    size_t size_of_the_chunk;</span><br><span class="line">    size_t size_of_the_previous_chunk;</span><br><span class="line">    void *chunks[10];</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; malloc(1024 * (i + 1));</span><br><span class="line">        chunks[i] &#x3D; (void *)((char *)p - 0x10);</span><br><span class="line">        printf(&quot;%p\n&quot;, p);</span><br><span class="line">    &#125;</span><br><span class="line">    free((char *)(chunks[3]) + 0x10);</span><br><span class="line">    free((char *)(chunks[7]) + 0x10);</span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; chunks[i];</span><br><span class="line">        printf(&quot;chunks[%d]: &quot;, i);</span><br><span class="line">        pmem(p, 0x10);</span><br><span class="line">        size_of_the_chunk &#x3D; *((size_t *)((char *)p + 8)) - 1;</span><br><span class="line">        size_of_the_previous_chunk &#x3D; *((size_t *)((char *)p));</span><br><span class="line">        printf(&quot;chunks[%d]: %p, size &#x3D; %li, prev &#x3D; %li\n&quot;,</span><br><span class="line">              i, p, size_of_the_chunk, size_of_the_previous_chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">编译运行输出：</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# gcc test.c -o test</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# .&#x2F;test</span><br><span class="line">0x55fbebf20260</span><br><span class="line">0x55fbebf20a80</span><br><span class="line">0x55fbebf21290</span><br><span class="line">0x55fbebf21ea0</span><br><span class="line">0x55fbebf22eb0</span><br><span class="line">0x55fbebf242c0</span><br><span class="line">0x55fbebf25ad0</span><br><span class="line">0x55fbebf276e0</span><br><span class="line">0x55fbebf296f0</span><br><span class="line">0x55fbebf2bb00</span><br><span class="line">chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00</span><br><span class="line">chunks[0]: 0x55fbebf20250, size &#x3D; 1040, prev &#x3D; 0</span><br><span class="line">chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00</span><br><span class="line">chunks[1]: 0x55fbebf20a70, size &#x3D; 2064, prev &#x3D; 0</span><br><span class="line">chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00</span><br><span class="line">chunks[2]: 0x55fbebf21280, size &#x3D; 3088, prev &#x3D; 0</span><br><span class="line">chunks[3]: 00 00 00 00 00 00 00 00 11 10 00 00 00 00 00 00</span><br><span class="line">chunks[3]: 0x55fbebf21e90, size &#x3D; 4112, prev &#x3D; 0</span><br><span class="line">chunks[4]: 10 10 00 00 00 00 00 00 10 14 00 00 00 00 00 00</span><br><span class="line">chunks[4]: 0x55fbebf22ea0, size &#x3D; 5135, prev &#x3D; 4112</span><br><span class="line">chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00</span><br><span class="line">chunks[5]: 0x55fbebf242b0, size &#x3D; 6160, prev &#x3D; 0</span><br><span class="line">chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00</span><br><span class="line">chunks[6]: 0x55fbebf25ac0, size &#x3D; 7184, prev &#x3D; 0</span><br><span class="line">chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00</span><br><span class="line">chunks[7]: 0x55fbebf276d0, size &#x3D; 8208, prev &#x3D; 0</span><br><span class="line">chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00</span><br><span class="line">chunks[8]: 0x55fbebf296e0, size &#x3D; 9231, prev &#x3D; 8208</span><br><span class="line">chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00</span><br><span class="line">chunks[9]: 0x55fbebf2baf0, size &#x3D; 10256, prev &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>程序代码通过free释放了3和7数据块的空间，所以4和8的前8个字节已经不全是0啦，和其它不同，它们表示之前数据块没有被分配的大小，也可以注意到4和8块的后8个字节不像其它块一样需要加1啦，可以得出结论，malloc通过是否加1来作为前一个数据块是否已经分配的标志，加1表示前一个数据块已经分配。所以之前的程序代码可以修改为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**                                                                                            </span><br><span class="line"> * pmem - print mem                                                                            </span><br><span class="line"> * @p: memory address to start printing from                                                   </span><br><span class="line"> * @bytes: number of bytes to print                                                            </span><br><span class="line"> *                                                                                             </span><br><span class="line"> * Return: nothing                                                                             </span><br><span class="line"> *&#x2F;</span><br><span class="line">void pmem(void *p, unsigned int bytes)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *ptr;</span><br><span class="line">    unsigned int i;</span><br><span class="line"></span><br><span class="line">    ptr &#x3D; (unsigned char *)p;</span><br><span class="line">    for (i &#x3D; 0; i &lt; bytes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%02x&quot;, *(ptr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - updating with correct checks</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line">    int i;</span><br><span class="line">    size_t size_of_the_chunk;</span><br><span class="line">    size_t size_of_the_previous_chunk;</span><br><span class="line">    void *chunks[10];</span><br><span class="line">    char prev_used;</span><br><span class="line"></span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; malloc(1024 * (i + 1));</span><br><span class="line">        chunks[i] &#x3D; (void *)((char *)p - 0x10);</span><br><span class="line">    &#125;</span><br><span class="line">    free((char *)(chunks[3]) + 0x10);</span><br><span class="line">    free((char *)(chunks[7]) + 0x10);</span><br><span class="line">    for (i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p &#x3D; chunks[i];</span><br><span class="line">        printf(&quot;chunks[%d]: &quot;, i);</span><br><span class="line">        pmem(p, 0x10);</span><br><span class="line">        size_of_the_chunk &#x3D; *((size_t *)((char *)p + 8));</span><br><span class="line">        prev_used &#x3D; size_of_the_chunk &amp; 1;</span><br><span class="line">        size_of_the_chunk -&#x3D; prev_used;</span><br><span class="line">        size_of_the_previous_chunk &#x3D; *((size_t *)((char *)p));</span><br><span class="line">        printf(&quot;chunks[%d]: %p, size &#x3D; %li, prev (%s) &#x3D; %li\n&quot;,</span><br><span class="line">              i, p, size_of_the_chunk,</span><br><span class="line">              (prev_used? &quot;allocated&quot;: &quot;unallocated&quot;), size_of_the_previous_chunk);</span><br><span class="line">    &#125;</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行输出：</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# gcc test.c -o test</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# .&#x2F;test</span><br><span class="line">chunks[0]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00</span><br><span class="line">chunks[0]: 0x56254f888250, size &#x3D; 1040, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[1]: 00 00 00 00 00 00 00 00 11 08 00 00 00 00 00 00</span><br><span class="line">chunks[1]: 0x56254f888660, size &#x3D; 2064, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[2]: 00 00 00 00 00 00 00 00 11 0c 00 00 00 00 00 00</span><br><span class="line">chunks[2]: 0x56254f888e70, size &#x3D; 3088, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[3]: 00 00 00 00 00 00 00 00 11 04 00 00 00 00 00 00</span><br><span class="line">chunks[3]: 0x56254f889a80, size &#x3D; 1040, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[4]: 00 0c 00 00 00 00 00 00 10 14 00 00 00 00 00 00</span><br><span class="line">chunks[4]: 0x56254f88aa90, size &#x3D; 5136, prev (unallocated) &#x3D; 3072</span><br><span class="line">chunks[5]: 00 00 00 00 00 00 00 00 11 18 00 00 00 00 00 00</span><br><span class="line">chunks[5]: 0x56254f88bea0, size &#x3D; 6160, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[6]: 00 00 00 00 00 00 00 00 11 1c 00 00 00 00 00 00</span><br><span class="line">chunks[6]: 0x56254f88d6b0, size &#x3D; 7184, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[7]: 00 00 00 00 00 00 00 00 11 20 00 00 00 00 00 00</span><br><span class="line">chunks[7]: 0x56254f88f2c0, size &#x3D; 8208, prev (allocated) &#x3D; 0</span><br><span class="line">chunks[8]: 10 20 00 00 00 00 00 00 10 24 00 00 00 00 00 00</span><br><span class="line">chunks[8]: 0x56254f8912d0, size &#x3D; 9232, prev (unallocated) &#x3D; 8208</span><br><span class="line">chunks[9]: 00 00 00 00 00 00 00 00 11 28 00 00 00 00 00 00</span><br><span class="line">chunks[9]: 0x56254f8936e0, size &#x3D; 10256, prev (allocated) &#x3D; 0</span><br></pre></td></tr></table></figure>

<h4 id="堆空间是向上增长吗"><a href="#堆空间是向上增长吗" class="headerlink" title="堆空间是向上增长吗"></a>堆空间是向上增长吗</h4><p>通过代码验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - moving the program break</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    write(1, &quot;START\n&quot;, 6);</span><br><span class="line">    malloc(1);</span><br><span class="line">    getchar();</span><br><span class="line">    write(1, &quot;LOOP\n&quot;, 5);</span><br><span class="line">    for (i &#x3D; 0; i &lt; 0x25000 &#x2F; 1024; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        malloc(1024);</span><br><span class="line">    &#125;</span><br><span class="line">    write(1, &quot;END\n&quot;, 4);</span><br><span class="line">    getchar();</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行部分摘要输出：</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# gcc test.c -o test</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# strace .&#x2F;test</span><br><span class="line">execve(&quot;.&#x2F;test&quot;, [&quot;.&#x2F;test&quot;], 0x7ffe0d7cbd80 &#x2F;* 10 vars *&#x2F;) &#x3D; 0</span><br><span class="line">brk(NULL)                               &#x3D; 0x555a2428f000</span><br><span class="line">access(&quot;&#x2F;etc&#x2F;ld.so.nohwcap&quot;, F_OK)      &#x3D; -1 ENOENT (No such file or directory)</span><br><span class="line">access(&quot;&#x2F;etc&#x2F;ld.so.preload&quot;, R_OK)      &#x3D; -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, &quot;&#x2F;etc&#x2F;ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) &#x3D; 3</span><br><span class="line">fstat(3, &#123;st_mode&#x3D;S_IFREG|0644, st_size&#x3D;13722, ...&#125;) &#x3D; 0</span><br><span class="line">mmap(NULL, 13722, PROT_READ, MAP_PRIVATE, 3, 0) &#x3D; 0x7f6423455000</span><br><span class="line">close(3)                                &#x3D; 0</span><br><span class="line">access(&quot;&#x2F;etc&#x2F;ld.so.nohwcap&quot;, F_OK)      &#x3D; -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, &quot;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6&quot;, O_RDONLY|O_CLOEXEC) &#x3D; 3</span><br><span class="line">read(3, &quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260\34\2\0\0\0\0\0&quot;..., 832) &#x3D; 832</span><br><span class="line">fstat(3, &#123;st_mode&#x3D;S_IFREG|0755, st_size&#x3D;2030544, ...&#125;) &#x3D; 0</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) &#x3D; 0x7f6423453000</span><br><span class="line">mmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) &#x3D; 0x7f6422e41000</span><br><span class="line">mprotect(0x7f6423028000, 2097152, PROT_NONE) &#x3D; 0</span><br><span class="line">mmap(0x7f6423228000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) &#x3D; 0x7f6423228000</span><br><span class="line">mmap(0x7f642322e000, 15072, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) &#x3D; 0x7f642322e000</span><br><span class="line">close(3)                                &#x3D; 0</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7f64234544c0) &#x3D; 0</span><br><span class="line">mprotect(0x7f6423228000, 16384, PROT_READ) &#x3D; 0</span><br><span class="line">mprotect(0x555a22f5f000, 4096, PROT_READ) &#x3D; 0</span><br><span class="line">mprotect(0x7f6423459000, 4096, PROT_READ) &#x3D; 0</span><br><span class="line">munmap(0x7f6423455000, 13722)           &#x3D; 0</span><br><span class="line">write(1, &quot;START\n&quot;, 6START</span><br><span class="line">)                  &#x3D; 6</span><br><span class="line">brk(NULL)                               &#x3D; 0x555a2428f000</span><br><span class="line">brk(0x555a242b0000)                     &#x3D; 0x555a242b0000</span><br><span class="line">fstat(0, &#123;st_mode&#x3D;S_IFCHR|0620, st_rdev&#x3D;makedev(136, 0), ...&#125;) &#x3D; 0</span><br><span class="line">read(0,</span><br><span class="line">&quot;\n&quot;, 1024)                     &#x3D; 1</span><br><span class="line">write(1, &quot;LOOP\n&quot;, 5LOOP</span><br><span class="line">)                   &#x3D; 5</span><br><span class="line">brk(0x555a242d1000)                     &#x3D; 0x555a242d1000</span><br><span class="line">brk(0x555a242f2000)                     &#x3D; 0x555a242f2000</span><br><span class="line">brk(0x555a24313000)                     &#x3D; 0x555a24313000</span><br><span class="line">brk(0x555a24334000)                     &#x3D; 0x555a24334000</span><br><span class="line">brk(0x555a24355000)                     &#x3D; 0x555a24355000</span><br><span class="line">brk(0x555a24376000)                     &#x3D; 0x555a24376000</span><br><span class="line">brk(0x555a24397000)                     &#x3D; 0x555a24397000</span><br><span class="line">brk(0x555a243b8000)                     &#x3D; 0x555a243b8000</span><br><span class="line">brk(0x555a243d9000)                     &#x3D; 0x555a243d9000</span><br><span class="line">brk(0x555a243fa000)                     &#x3D; 0x555a243fa000</span><br></pre></td></tr></table></figure>
<p>可以看出堆空间是向上增长的.  </p>
<h4 id="随机化地址空间布局"><a href="#随机化地址空间布局" class="headerlink" title="随机化地址空间布局"></a>随机化地址空间布局</h4><p>从开始到现在运行了好多个进程，通过查看对应进程的maps，发现每个进程的heap的起始地址和可执行程序的结束地址都不紧邻，而且差距还每次都不相同.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[3718]: 01195000 – 00602000 &#x3D; b93000</span><br><span class="line">[3834]: 024d6000 – 00602000 &#x3D; 1ed4000</span><br><span class="line">[4014]: 00e70000 – 00602000 &#x3D; 86e000</span><br><span class="line">[4172]: 01314000 – 00602000 &#x3D; d12000</span><br><span class="line">[7972]: 00901000 – 00602000 &#x3D; 2ff000</span><br></pre></td></tr></table></figure>
<p>可以看出这个差值是随机的，查看fs/binfmt_elf.c源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; 1)) &#123;</span><br><span class="line">                current-&gt;mm-&gt;brk &#x3D; current-&gt;mm-&gt;start_brk &#x3D;</span><br><span class="line">                        arch_randomize_brk(current-&gt;mm);</span><br><span class="line">#ifdef compat_brk_randomized</span><br><span class="line">                current-&gt;brk_randomized &#x3D; 1;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">&#x2F;&#x2F; current-&gt;mm-&gt;brk是当前进程程序中断的地址</span><br></pre></td></tr></table></figure>
<p>arch_randomize_brk函数在arch/x86/kernel/process.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unsigned long arch_randomize_brk(struct mm_struct *mm)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned long range_end &#x3D; mm-&gt;brk + 0x02000000;</span><br><span class="line">        return randomize_range(mm-&gt;brk, range_end, 0) ? : mm-&gt;brk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>randomize_range函数在drivers/char/random.c中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * randomize_range() returns a start address such that</span><br><span class="line"> *</span><br><span class="line"> *    [...... &lt;range&gt; .....]</span><br><span class="line"> *  start                  end</span><br><span class="line"> *</span><br><span class="line"> * a &lt;range&gt; with size &quot;len&quot; starting at the return value is inside in the</span><br><span class="line"> * area defined by [start, end], but is otherwise randomized.</span><br><span class="line"> *&#x2F;</span><br><span class="line">unsigned long</span><br><span class="line">randomize_range(unsigned long start, unsigned long end, unsigned long len)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned long range &#x3D; end - len - start;</span><br><span class="line"></span><br><span class="line">        if (end &lt;&#x3D; start + len)</span><br><span class="line">                return 0;</span><br><span class="line">        return PAGE_ALIGN(get_random_int() % range + start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出上面所说的这个差值其实就是0-0x02000000中的一个随机数，这种技术称为ASLR(Address Space Layout Randomisation)，是一种计算机安全技术，随机安排虚拟内存中堆栈空间的位置，可以有效防止黑客攻击。<br>通过以上分析，可以画出内存分布图如下：<br><img width=350 src="/image/virtual_memory_diagram_v2.png" >   </p>
<h4 id="malloc-0-发生了什么"><a href="#malloc-0-发生了什么" class="headerlink" title="malloc(0)发生了什么"></a>malloc(0)发生了什么</h4><p>当调用malloc(0)会发生什么，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**                                                                                            </span><br><span class="line"> * pmem - print mem                                                                            </span><br><span class="line"> * @p: memory address to start printing from                                                   </span><br><span class="line"> * @bytes: number of bytes to print                                                            </span><br><span class="line"> *                                                                                             </span><br><span class="line"> * Return: nothing                                                                             </span><br><span class="line"> *&#x2F;</span><br><span class="line">void pmem(void *p, unsigned int bytes)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char *ptr;</span><br><span class="line">    unsigned int i;</span><br><span class="line"></span><br><span class="line">    ptr &#x3D; (unsigned char *)p;</span><br><span class="line">    for (i &#x3D; 0; i &lt; bytes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i !&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%02x&quot;, *(ptr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * main - moving the program break</span><br><span class="line"> *</span><br><span class="line"> * Return: EXIT_FAILURE if something failed. Otherwise EXIT_SUCCESS</span><br><span class="line"> *&#x2F;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line">    size_t size_of_the_chunk;</span><br><span class="line">    char prev_used;</span><br><span class="line"></span><br><span class="line">    p &#x3D; malloc(0);</span><br><span class="line">    printf(&quot;%p\n&quot;, p);</span><br><span class="line">    pmem((char *)p - 0x10, 0x10);</span><br><span class="line">    size_of_the_chunk &#x3D; *((size_t *)((char *)p - 8));</span><br><span class="line">    prev_used &#x3D; size_of_the_chunk &amp; 1;</span><br><span class="line">    size_of_the_chunk -&#x3D; prev_used;</span><br><span class="line">    printf(&quot;chunk size &#x3D; %li bytes\n&quot;, size_of_the_chunk);</span><br><span class="line">    return (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line">编译运行输出如下：</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# gcc test.c -o test</span><br><span class="line">root@3e8650948c0c:&#x2F;ubuntu# .&#x2F;test</span><br><span class="line">0x564ece64b260</span><br><span class="line">00 00 00 00 00 00 00 00 21 00 00 00 00 00 00 00</span><br><span class="line">chunk size &#x3D; 32 bytes</span><br></pre></td></tr></table></figure>
<p>可以看出malloc(0)实际使用了32个字节，其中包括我们之前说的16个字节头部，然而有时候malloc(0)可能会有不同的结果输出，也有可能会返回NULL.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man malloc</span><br><span class="line">NULL may also be returned by a successful call to malloc() with a size of zero</span><br></pre></td></tr></table></figure>

<h4 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例代码主要在两种环境下跑过：</span><br><span class="line">ubuntu 16.04</span><br><span class="line">gcc (Ubuntu 7.4.0-1ubuntu1~16.04~ppa1) 7.4.0</span><br><span class="line"></span><br><span class="line">ubuntu 18.04 docker</span><br><span class="line">gcc (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0</span><br></pre></td></tr></table></figure>
    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/02/13/C++type_traits/" title= "C++type_traits">
                    <div class="nextTitle">C++type_traits</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/02/06/%E6%B5%85%E8%B0%88C++%E7%9A%84ScopeExit/" title= "浅谈C++的ScopeExit">
                    <div class="prevTitle">浅谈C++的ScopeExit</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:fightingwangzq@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/fightingwangzq" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat.jpg" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-proc文件系统探究虚拟内存"><span class="toc-number">1.</span> <span class="toc-text">通过&#x2F;proc文件系统探究虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟内存"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mem-amp-maps"><span class="toc-number">1.1.1.</span> <span class="toc-text">mem &amp; maps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过实践画出虚拟内存空间分布图"><span class="toc-number">2.</span> <span class="toc-text">通过实践画出虚拟内存空间分布图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#堆栈空间"><span class="toc-number">2.1.</span> <span class="toc-text">堆栈空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可执行程序"><span class="toc-number">2.2.</span> <span class="toc-text">可执行程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令行参数和环境变量"><span class="toc-number">2.3.</span> <span class="toc-text">命令行参数和环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#argv和env数组地址是相邻的吗"><span class="toc-number">2.4.</span> <span class="toc-text">argv和env数组地址是相邻的吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命令行参数地址紧随环境变量地址之后吗"><span class="toc-number">2.5.</span> <span class="toc-text">命令行参数地址紧随环境变量地址之后吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#栈内存真的向下增长吗"><span class="toc-number">2.6.</span> <span class="toc-text">栈内存真的向下增长吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆内存-malloc"><span class="toc-number">3.</span> <span class="toc-text">堆内存(malloc)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-number">3.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不调用malloc，就不会有堆空间-heap"><span class="toc-number">3.2.</span> <span class="toc-text">不调用malloc，就不会有堆空间[heap]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strace-brk-sbrk"><span class="toc-number">3.3.</span> <span class="toc-text">strace, brk, sbrk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多次malloc"><span class="toc-number">3.4.</span> <span class="toc-text">多次malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0x10-那丢失的16字节是什么"><span class="toc-number">3.5.</span> <span class="toc-text">0x10 那丢失的16字节是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆空间是向上增长吗"><span class="toc-number">3.6.</span> <span class="toc-text">堆空间是向上增长吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#随机化地址空间布局"><span class="toc-number">3.7.</span> <span class="toc-text">随机化地址空间布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-0-发生了什么"><span class="toc-number">3.8.</span> <span class="toc-text">malloc(0)发生了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#操作环境"><span class="toc-number">3.9.</span> <span class="toc-text">操作环境</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 8
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/13</span><a class="archive-post-title" href= "/2020/02/13/C++type_traits/" >C++type_traits</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/08</span><a class="archive-post-title" href= "/2020/02/08/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" >深入浅出虚拟内存</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2020/02/06/%E6%B5%85%E8%B0%88C++%E7%9A%84ScopeExit/" >浅谈C++的ScopeExit</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2020/02/06/%E6%B5%85%E8%B0%88Linux%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%9C%BA%E5%88%B6/" >浅谈Linux零拷贝机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2020/02/06/C++%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" >C++迭代器注意事项</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2020/02/06/C++%E6%A8%A1%E6%9D%BF%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99/" >C++模板型别推导机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2020/02/06/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" >C++设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span><a class="archive-post-title" href= "/2020/02/06/sqlite3%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" >sqlite3总结</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "王志强"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


